[
   {
      "meta": "/**\n * VscTemplate types",
      "body": "const AAAAA = 'first order for compiling!' // This is only used cfor compile script!\nexport type vscTemplate = {\n   userInputs: vscUserInput[]\n   template: vscTemplateItem[]\n}\n\nexport type vscTemplateItem = vscTemplateFolder | vscTemplateFile\n\nexport type vscTemplateFolder = {\n   type: 'folder'\n   name: vscStringDelegate\n   children?: vscTemplateItem[]\n}\nexport type vscTemplateFile = {\n   type: 'file'\n   name: vscStringDelegate\n   content: vscStringDelegate\n}\n\nexport type vscUserInput = {\n   title: string\n   argumentName: string\n   defaultValue: string\n}\nexport type vscUserInputs = { [key: string]: string }\nexport type vscStringDelegate = string | ((inputs: vscUserInputs) => string)\n"
   },
   {
      "meta": " * Add './' to start of path\n * @param path\n * @see http://vsc-base.org/#addLeadingLocalDash\n * @returns string",
      "body": "export const addLeadingLocalDash = (path: string): string => {\n   return './' + path\n}\n"
   },
   {
      "meta": " * Append new line content in the end of the open document\n * @param content\n * @dependencyInternal appendToActiveDocument\n * @oneLineEx const success = await vsc.appendLineToActiveDocument(content)\n * @see http://vsc-base.org/#appendLineToActiveDocument\n * @returns Promise<boolean>",
      "body": "export const appendLineToActiveDocument = async (\n   content: string\n): Promise<boolean> => {\n   return await appendToActiveDocument('\\n' + content)\n}\n"
   },
   {
      "meta": " * Append new content in the end of the open document.\n * Return true for succes, and false if there was no active editor or open document\n * @param content\n * @dependencyInternal getActiveDocument, getActiveEditor\n * @dependencyExternal vscode\n * @oneLineEx const success = await vsc.appendToActiveDocument(content)\n * @see http://vsc-base.org/#appendToActiveDocument\n * @returns Promise<boolean>",
      "body": "export const appendToActiveDocument = async (\n   content: string\n): Promise<boolean> => {\n   const document = getActiveDocument()\n   const editor = getActiveEditor()\n   if (document && editor) {\n      await appendToDocument(editor, document, content)\n      return true\n   }\n   return false\n}"
   },
   {
      "meta": " * Append new content in the end of the open document\n * @param editor\n * @param document\n * @param content\n * @dependencyExternal vscode\n * @oneLineEx await vsc.appendToDocument(editor, document, content)\n * @see http://vsc-base.org/#appendToDocument\n * @returns Promise<void>",
      "body": "export const appendToDocument = async (\n   editor: vscode.TextEditor,\n   document: vscode.TextDocument,\n   content: string\n): Promise<void> => {\n   const startPosition = new vscode.Position(document.lineCount, 0)\n   const endPosition = new vscode.Position(document.lineCount, 0)\n   const fullRange = new vscode.Range(startPosition, endPosition)\n   const snippetString = new vscode.SnippetString(content)\n   await editor.insertSnippet(snippetString, fullRange)\n}\n"
   },
   {
      "meta": " * Prompt user for a question\n * @param path\n * @dependencyExternal vscode\n * @oneLineEx const answer = await ask(question, defaultValue)\n * @ex const answer = await ask('Where to move file?', currentFilePath)\n * @see http://vsc-base.org/#ask\n * @returns Promise<string | undefined>",
      "body": "export const ask = async (\n   question: string,\n   defaultValue: string\n): Promise<string | undefined> =>\n   await vscode.window.showInputBox({\n      prompt: question,\n      value: defaultValue\n   })\n"
   },
   {
      "meta": " * Ensure that a method result that optional can be a promise is awaited.\n * (Responses from methods loaded with vsc.loadTsModule can be optional async!)\n * @oneLineEx await awaitResult(result)\n * @ex \nconst varifiedModule = vsc.hasModuleFunction(_module, \\['run'])\nconst result = varifiedModule.run()\nawait awaitResult(result)\n * @see http://vsc-base.org/#awaitResult\n * @returns Promise<any>",
      "body": "export const awaitResult = async (result: any): Promise<any> => {\n   if (result instanceof Promise) {\n      return result\n   } else {\n      return new Promise(resolve => {\n         resolve(result)\n      })\n   }\n}\n"
   },
   {
      "meta": " * Format a string from camel-case to kebab-case. Commonly used to define css class names. (SomeName => some-name)\n * @param str\n * @see http://vsc-base.org/#camalcaseToKebabcase\n * @returns string",
      "body": "export const camalcaseToKebabcase = (str: string): string =>\n   str[0].toLowerCase() +\n   str.substr(1).replace(/([A-Z])/g, ([letter]) => `-${letter.toLowerCase()}`)\n"
   },
   {
      "meta": " * Get clean path. folder/../folder/file => folder/file, folder/./file => file\n * @param path\n * @see http://vsc-base.org/#cleanPath\n * @returns string",
      "body": "export const cleanPath = (path: string): string => {\n   path = path.replace(/\\/.\\//g, '/')\n   const reg = /\\/\\w+\\/\\.\\.\\//\n   while (reg.test(path)) {\n      path = path.replace(reg, '/')\n   }\n   return path\n}\n"
   },
   {
      "meta": " * Does the folder/file exist\n * @param path string\n * @dependencyExternal fs\n * @oneLineEx const exist = vsc.doesExists(path)\n * @see http://vsc-base.org/#doesExists\n * @returns boolean",
      "body": "export const doesExists = (path: string): boolean => {\n   return fs.existsSync(path)\n}\n"
   },
   {
      "meta": " * Get a list off all filePaths in project the matches a glob pattern\n * @param include glob\n * @param exclude glob\n * @param maxResults\n * @dependencyExternal vscode\n * @dependencyInternal pathAsUnix\n * @oneLineEx const files = await vsc.findFilePaths(includePattern)\n * @ex \nconst allTestFiles = await vsc.findFilePaths('**\\/*.test.{ts,jsx,ts,tsx}')\nfor (const filePath of allTestFiles){ // <-- enable aync action for each filePath\n   // Do something with filePath\n}\n * @see http://vsc-base.org/#findFilePaths\n * @returns Promise<string[]>",
      "body": "export const findFilePaths = async (\n   include: vscode.GlobPattern = '**/*.{js,jsx,ts,tsx}',\n   exclude: vscode.GlobPattern = '**/node_modules/**',\n   maxResults: number = 100000\n): Promise<string[]> => {\n   const uriFiles = await vscode.workspace.findFiles(\n      include,\n      exclude,\n      maxResults\n   )\n   const files = uriFiles.map((uri: vscode.Uri) => pathAsUnix(uri.fsPath))\n   return files\n}\n"
   },
   {
      "meta": " * Get a list off all filePaths from a basePath, in project the matches a glob pattern\n * @param include glob\n * @param exclude glob\n * @dependencyExternal vscode\n * @dependencyInternal getDir, findFilePaths\n * @param maxResults\n * @oneLineEx const files = await vsc.findFilePathsFromBase(dir, includePattern)\n * @ex \nconst storyFilesInModule1 = await vsc.findFilePathsFromBase('c:/root/src/module1', '*.story.{ts,tsx}')\nfor (const filePath of storyFilesInModule1){ // <-- enable aync action for each filePath\n   // Do something with filePath..\n}\n * @see http://vsc-base.org/#findFilePathsFromBase\n * @returns Promise<string[]>",
      "body": "export const findFilePathsFromBase = async (\n   basePath: string,\n   includePattern: string = '**/*.{js,jsx,ts,tsx}',\n   exclude: vscode.GlobPattern = '**/node_modules/**',\n   maxResults: number = 100000\n): Promise<string[]> => {\n   let baseDir = getDir(basePath)\n   const include = new vscode.RelativePattern(baseDir, includePattern)\n   const filePaths = await findFilePaths(include, exclude, maxResults)\n   return filePaths\n}\n"
   },
   {
      "meta": " * Find files based from a releative to a path\n * @param path\n * @param relativePath\n * @param includePattern\n * @param exclude\n * @param maxResults\n * @dependencyExternal vscode\n * @dependencyInternal getDir, joinPath, cleanPath, trimDases, findFilePathsFromBase\n * @oneLineEx const files = await vsc.findRelativeFilePaths(path, relativePath, includePattern)\n * @ex \nconst moduleFileInParentFolder = await vsc.findRelativeFilePaths(path, '../', '*Module.ts')\nif(moduleFileInParentFolder.lenght===0){\n   vsc.showErrorMessage('Module file was not found in parent folder')\n   return\n}\nif(moduleFileInParentFolder.lenght>1){\n   vsc.showErrorMessage('More than one Module file was found in parent folder')\n   return\n}\nconst modulePath = moduleFileInParentFolder[0];\n// Do something with modulePath..\n * @see http://vsc-base.org/#findRelativeFilePaths\n * @returns Promise<string[]>",
      "body": "export const findRelativeFilePaths = async (\n   path: string,\n   relativePath: string,\n   includePattern: string = '**/*.{js,jsx,ts,tsx}',\n   exclude: vscode.GlobPattern = '**/node_modules/**',\n   maxResults: number = 100000\n): Promise<string[]> => {\n   const dir = getDir(path)\n   const joinPath = joinPaths(dir, relativePath)\n   let base = cleanPath(joinPath + '/')\n   base = trimDashes(base)\n   const filePaths = await findFilePathsFromBase(\n      base,\n      includePattern,\n      exclude,\n      maxResults\n   )\n   return filePaths\n}\n"
   },
   {
      "meta": " * Get open vscode.TextDocument\n * @dependencyExternal vscode\n * @oneLineEx const document = vsc.getActiveDocument()\n * @see http://vsc-base.org/#getActiveDocument\n * @returns vscode.TextDocument | undefined",
      "body": "export const getActiveDocument = (): vscode.TextDocument | undefined => {\n   const activeEditor = getActiveEditor()\n   const document = activeEditor && activeEditor.document\n   return document\n}\n"
   },
   {
      "meta": " * Get current open file's content.\n * @dependencyInternal getActiveDocument\n * @oneLineEx const content = vsc.getActiveDocumentContent()\n * @see http://vsc-base.org/#getActiveDocumentContent\n * @returns string | undefined",
      "body": "export const getActiveDocumentContent = (): string | undefined => {\n   const document = getActiveDocument()\n   return (document && document.getText()) || undefined\n}\n"
   },
   {
      "meta": " * Get current open file path or undefined if nothing is open.\n * @dependencyInternal getActiveDocument\n * @oneLineEx const path = vsc.getActivegetActiveDocumentPath()\n * @see http://vsc-base.org/#getActivegetActiveDocumentPath\n * @returns string | undefined",
      "body": "export const getActiveDocumentPath = (): string | undefined => {\n   const document = getActiveDocument()\n   return (document && document.fileName) || undefined\n}\n"
   },
   {
      "meta": " * Get vscode.activeTextEditor\n * @dependencyExternal vscode\n * @oneLineEx const editor = vsc.getActiveEditor()\n * @see http://vsc-base.org/#getActiveDocument\n * @returns vscode.TextEditor | undefined",
      "body": "export const getActiveEditor = (): vscode.TextEditor | undefined => {\n   return vscode.window.activeTextEditor\n}"
   },
   {
      "meta": " * Get vscode project config\n * @dependencyExternal vscode\n * @oneLineEx const myOption = vsc.getConfig(projectName, optionName, defaultValue)\n * @ex const myOption = vsc.getConfig('myExtension', 'doThisThing', false)\n * @see http://vsc-base.org/#getConfig\n * @returns T",
      "body": "export const getConfig = <T>(\n   projectName: string,\n   property: string,\n   defaultValue: T\n): T => {\n   return vscode.workspace\n      .getConfiguration(projectName)\n      .get<T>(property, defaultValue)\n}\n"
   },
   {
      "meta": " * Get dir from path (If path is a dir return it)\n * @param path\n * @dependencyInternal isDir, splitPath\n * @oneLineEx const dir = vsc.getDir(path)\n * @see http://vsc-base.org/#getDir\n * @returns string",
      "body": "export const getDir = (path: string) => {\n   const _isDir = isDir(path)\n   if (_isDir) {\n      return path\n   }\n   const [dir] = splitPath(path)\n   return dir\n}\n"
   },
   {
      "meta": " * Get file source\n * @param path\n * @dependencyExternal fs\n * @oneLineEx const source = vsc.getFileContent(path)\n * @see http://vsc-base.org/#getFileContent\n * @returns Promise<string>",
      "body": "export const getFileContent = async (path: string): Promise<string> =>\n   await fs.readFile(path, 'utf8')\n"
   },
   {
      "meta": " * Get a vscodeRange for the entire document\n * @param document\n * @dependencyExternal vscode\n * @oneLineEx const fullRange = vsc.getFullDocumentRange(document)\n * @see http://vsc-base.org/#getFullDocumentRange\n * @returns boolean",
      "body": "export const getFullDocumentRange = (\n   document: vscode.TextDocument\n): vscode.Range => {\n   const startPosition = new vscode.Position(0, 0)\n   const endPosition = new vscode.Position(document.lineCount, 0)\n   const fullRange = new vscode.Range(startPosition, endPosition)\n   return fullRange\n}\n"
   },
   {
      "meta": " * Get file source as json (return null on invalid json)\n * @param path\n * @dependencyExternal fs\n * @oneLineEx const json = await vsc.getJsonContent(path)\n * @see http://vsc-base.org/#getJsonContent\n * @returns unknown",
      "body": "export const getJsonContent = async (\n   path: string,\n   throws = false\n): Promise<unknown> => await fs.readJson(path, { throws })\n"
   },
   {
      "meta": " * Get part of a json object.\n * @param json\n * @param keyPath Ex sub.sub.name >> {sub:{sub:{name:'Foo'}}} >> Foo\n * @see http://vsc-base.org/#getJsonParts\n * @returns any",
      "body": "export const getJsonParts = (\n   json: { [name: string]: any },\n   keyPath: string\n): any => {\n   let current: any = json\n   const keySplit = keyPath.split(/\\./)\n   for (let i = 0; i < keySplit.length; i++) {\n      const key = keySplit[i]\n      if (current[key] === undefined) {\n         return undefined\n      }\n      current = current[key]\n   }\n   return current\n}\n"
   },
   {
      "meta": " * Create a LineReader (generator method) for a ReadStream\n * @param readStream\n * @dependencyExternal fs\n * @oneLineEx const lineReader = getLineStreamReader(readStream)\n * @ex\n const readStream = getReadStream(path)\n const lineReader = getLineStreamReader(readStream)\n for await (line of lineReader) {\n    //do something with the line\n }\n * @see http://vsc-base.org/#getLineStreamReader\n * @returns () => AsyncIterableIterator<string>",
      "body": "export const getLineStreamReader = (readStream: fs.ReadStream) =>\n   async function*() {\n      let read = ''\n      for await (const chunk of readStream) {\n         read += chunk\n         let lineLength: number\n         while ((lineLength = read.indexOf('\\n')) >= 0) {\n            const line = read.slice(0, lineLength + 1)\n            yield line\n            read = read.slice(lineLength + 1)\n         }\n      }\n      if (read.length > 0) {\n         yield read\n      }\n   }\n"
   },
   {
      "meta": " * Find package.json files and collect the dependencies and devDependencies.\n * @dependencyInternal getPackageFilePaths, getJsonContent, getJsonParts\n * @oneLineEx const [dependencies, devDependencies] = await vsc.getPackageDependencies()\n * @todo Use unknow guard check instead of any casting\n * @see http://vsc-base.org/#getPackageDependencies\n * @returns Promise<{ [key: string]: string }[]",
      "body": "export const getPackageDependencies = async (): Promise<\n   { [key: string]: string }[]\n> => {\n   let dependencies: { [k: string]: string } = {}\n   let devDependencies: { [k: string]: string } = {}\n   const packageFilePaths = await getPackageFilePaths()\n   for (let i = 0; i < packageFilePaths.length; i++) {\n      const packageFile = packageFilePaths[i]\n      const packageJson = await getJsonContent(packageFile)\n      if (!packageJson) {\n         continue\n      }\n      const packageDependencies = getJsonParts(<any>packageJson, 'dependencies')\n      const packageDevDependencies = getJsonParts(\n         <any>packageJson,\n         'devDependencies'\n      )\n      if (packageDependencies) {\n         dependencies = { ...dependencies, ...packageDependencies }\n      }\n      if (packageDevDependencies) {\n         devDependencies = { ...devDependencies, ...packageDevDependencies }\n      }\n   }\n   return [dependencies, devDependencies]\n}\n"
   },
   {
      "meta": " * Find packages file paths in project.\n * @dependencyInternal findFilePaths\n * @oneLineEx const packageFilePaths = await vsc.getPackageFilePaths()\n * @see http://vsc-base.org/#getPackageFilePaths\n * @returns Promise<string[]>",
      "body": "export const getPackageFilePaths = async (): Promise<string[]> => {\n   const packageFiles = await findFilePaths('**/package.json')\n   return packageFiles\n}\n"
   },
   {
      "meta": " * Get a file ReadStream\n * @param path\n * @dependencyExternal fs\n * @oneLineEx const readStream = getReadStream(path)\n * @ex\n const readStream = getReadStream(path)\n for await (chunk of readStream) {\n   //do something with chunk\n }\n * @see http://vsc-base.org/#getReadStream\n * @returns fs.ReadStream",
      "body": "export const getReadStream = (path: string) => {\n   const stream = fs.createReadStream(path, {\n      flags: 'r',\n      encoding: 'utf-8',\n      fd: undefined,\n      mode: 438, // 0666 in Octal\n      autoClose: false,\n      highWaterMark: 64 * 1024\n   })\n   return stream\n}\n"
   },
   {
      "meta": " * Generate relative path between two paths.\n * @param fromPath\n * @param toPath\n * @testPrinterArgument fromPath: 'c:/somefolder/sub1/sub2/someFile.js'\n * @testPrinterArgument toPath: 'c:/somefolder/other/someFile.js'\n * @testPrinter\n( \n   args = getRelativePath.testArguments, \n   printResult: (str: string) => void\n) => {\n   const relativePath = getRelativePath(args.fromPath, args.toPath)\n   printResult(relativePath)\n}\n * @dependencyInternal sharedPath, splitPath, subtractPath\n * @see http://vsc-base.org/#relatrivePath\n * @returns string",
      "body": "export const getRelativePath = (fromPath: string, toPath: string): string => {\n   const _sharedPath = sharedPath(fromPath, toPath)\n   const [fromDir] = splitPath(fromPath)\n   const [toDir] = splitPath(toPath)\n   const fromPathDownToShared = subtractPath(fromDir, _sharedPath)\n   let toPathDownToShared = subtractPath(toDir, _sharedPath)\n   const backPath = fromPathDownToShared\n      .split(/\\//)\n      .map(_ => '../')\n      .join('')\n   const relativePath = backPath + toPathDownToShared\n   return relativePath\n}\n"
   },
   {
      "meta": " * Get project root for a path or undefined if no project was found.\n * @param path\n * @dependencyExternal vscode\n * @dependencyInternal pathAsUnix\n * @oneLineEx const rootPath = vsc.getRootPath()\n * @see http://vsc-base.org/#getRootPath\n * @returns string | undefined",
      "body": "export const getRootPath = (path: string): string | undefined => {\n   const uri = vscode.Uri.file(path)\n   const workspaceFolder = vscode.workspace.getWorkspaceFolder(uri)\n   if (!workspaceFolder) {\n      return undefined\n   }\n   let rootPath = workspaceFolder.uri.fsPath\n   rootPath = pathAsUnix(rootPath)\n   return rootPath\n}\n"
   },
   {
      "meta": "/**\n * Transform an absolute path from root, to a sub-relative path.\n * @param path\n * @param rootPath\n * @param absolutePathFromRoot\n * @dependencyInternal splitPath, subtractPath, addLeadingLocalDash\n * @see http://vsc-base.org/#getSubrelativePathFromAbsoluteRootPath\n * @returns string\n * @test",
      "body": "export const getSubrelativePathFromAbsoluteRootPath = (\n   path: string,\n   absolutePathFromRoot: string,\n   rootPath: string\n): string => {\n   const [sourceDirPath] = splitPath(path)\n   let sourceDirPathFromRoot = subtractPath(sourceDirPath, rootPath)\n   sourceDirPathFromRoot = sourceDirPathFromRoot + '/'\n   let absolutePathFromSourceDir = subtractPath(\n      absolutePathFromRoot,\n      sourceDirPathFromRoot\n   )\n   if (absolutePathFromSourceDir !== absolutePathFromRoot) {\n      absolutePathFromSourceDir = addLeadingLocalDash(absolutePathFromSourceDir)\n   }\n   return absolutePathFromSourceDir\n}\n"
   },
   {
      "meta": " * Does path start with charactor [a-zA-Z@] (not '/' or './' or '../')\n * @param path\n * @param startWithRegExp? If your project defines another definition of absolute path then overwrite this.\n * @see http://vsc-base.org/#isAbsolutePath\n * @returns boolean",
      "body": "export const isAbsolutePath = (\n   path: string,\n   startWithRegExp = /^[a-zA-Z@]/\n): boolean => {\n   return startWithRegExp.test(path)\n}\n"
   },
   {
      "meta": " * Test is a path is directory\n * @param path\n * @dependencyExternal fs\n * @oneLineEx const _isDir = vsc.isDir(path)\n * @see http://vsc-base.org/#isDir\n * @returns boolean",
      "body": "export const isDir = (path: string): boolean => {\n   return fs.statSync(path).isDirectory()\n}\n"
   },
   {
      "meta": " * Does subpath start with parentPath\n * @param path\n * @param parentPath\n * @dependencyInternal trimDashes\n * @see http://vsc-base.org/#isSubPath\n * @returns boolean",
      "body": "export const isSubPath = (subPath: string, parentPath: string): boolean => {\n   parentPath = trimDashes(parentPath)\n   const result = subPath.indexOf(parentPath + '/') === 0\n   return result\n}\n"
   },
   {
      "meta": " * Joins to paths.\n * @param path1\n * @param path2\n * @dependencyInternal trimDashes\n * @see http://vsc-base.org/#joinPaths\n * @returns string",
      "body": "export const joinPaths = (path1: string, path2: string): string => {\n   path1 = trimDashes(path1)\n   path2 = trimDashes(path2)\n   const result = path1 + '/' + path2\n   return result\n}\n"
   },
   {
      "meta": " * Load a ts file. Transpile it to js (run time) add wrap code and execute it (using eval)!\n * Returning an plainObject with the scripts exports.\n * export default xxx transpile s to export.default\n * IMPORTANT Dont just run code you dont now, this can cause injection!\n * IMPORTANT Be carefull when running scripts that also uses loadTsModule, this can break down entire systems!\n * (If you start a recursive change that dont stop..)\n * @param path\n * @dependencyExternal ts\n * @dependencyInternal getFileContent, showErrorMessage\n * @oneLineEx const module = await vsc.loadTsModule(path)\n * @ex\nlet _module\ntry {\n   _module = await vsc.loadTsModule(path)\n} catch (e){\n   vsc.showErrorMessage(`Loadeding module coused an error: ${e}`)\n   return\n}\nconst varifiedModule = vsc.varifyModuleMethods(_module, ['run'])\nif (!varifiedModule) {\n   vsc.showErrorMessage(`Module didnt have 'run' :: ${JSON.stringify(_module)}`)\n   return\n}\ntry {\n   const result = varifiedModule.run()\n   await vsc.awaitResult(result)\n   vsc.showMessage(`Loaded Run resulted with value: ${result}`)\n} catch (e) {\n   vsc.showErrorMessage('Error: ' + e)\n}\n * @see http://vsc-base.org/#loadTsModule\n * @returns Promise<{ [key: string]: unknown; }>",
      "body": "export const loadTsModule = async (\n   path: string,\n   vsc: any\n): Promise<{ [key: string]: unknown }> => {\n   const scriptFileTs = await getFileContent(path)\n   const transpiledOutput = ts.transpileModule(scriptFileTs, {})\n   const sourceJs = transpiledOutput.outputText\n   const wrapExports = `_exports = (function (vsc){var exports = {};${sourceJs};return exports})(vsc);`\n   let _exports: { [key: string]: unknown } = {}\n   try {\n      eval(wrapExports)\n   } catch (e) {\n      throw e // retrhow\n   }\n   return _exports\n}\n"
   },
   {
      "meta": " * Make a folder\n * @param path\n * @param newPathstring\n * @dependencyExternal fs\n * @oneLineEx await vsc.makeDir(path)\n * @see http://vsc-base.org/#makeDir\n * @returns Promise<void>",
      "body": "export const makeDir = async (folderPath: string): Promise<void> => {\n   try {\n      await fs.mkdir(folderPath)\n   } catch (e) {\n      throw e\n   }\n}\n"
   },
   {
      "meta": " * Move file/fodler\n * @param path\n * @param newPathstring\n * @oneLineEx await vsc.move(oldPath, newPath)\n * @dependencyExternal fs\n * @see http://vsc-base.org/#move\n * @returns Promise<void>",
      "body": "export const move = async (path: string, newPath: string): Promise<void> => {\n   await fs.move(path, newPath)\n}\n"
   },
   {
      "meta": " * Reaplve all '\\\\'  with '/'\n * @param path\n * @see http://vsc-base.org/#pathAsUnix\n * @returns string",
      "body": "export const pathAsUnix = (path: string): string => {\n   return path.replace(/\\\\/g, '/')\n}\n"
   },
   {
      "meta": " * Prompt user for a question with a list of answers\n * @param path\n * @dependencyExternal vscode\n * @oneLineEx const answer = await pick(answers)\n * @ex const answer = await ask(\\['yes', 'no'\\])\n * @see http://vsc-base.org/#pick\n * @returns Promise<string | undefined>",
      "body": "export const pick = async (answerList: string[]): Promise<string | undefined> =>\n   await vscode.window.showQuickPick(answerList)\n"
   },
   {
      "meta": " * Transform a relative path to an abspolute path.\n * @param path File from where the relative path begins\n * @param pathRelatriveToPath The relative path\n * @param rootPath The root path\n * @param realPathTest Test if the real  The root path\n * @dependencyInternal isAbsolutePath, splitPath, cleanPath, subtractPath, trimLeadingDash\n * @see http://vsc-base.org/#relatrivePathToAbsolutePath\n * @returns string",
      "body": "export const relatrivePathToAbsolutePath = (\n   path: string,\n   pathRelatriveToPath: string,\n   rootPath: string\n): string => {\n   if (isAbsolutePath(pathRelatriveToPath)) {\n      return pathRelatriveToPath\n   }\n   let [dir] = splitPath(path)\n   dir += '/'\n   const relativePath = dir + pathRelatriveToPath\n   let cleanRelativePath = cleanPath(relativePath)\n   let absolutePathToRelative = subtractPath(cleanRelativePath, rootPath)\n   absolutePathToRelative = trimLeadingDash(absolutePathToRelative)\n   return absolutePathToRelative\n}\n"
   },
   {
      "meta": " * Save active open file.\n * Return true for succes, and false if there was no open document\n * @dependencyInternal getActiveDocument\n * @oneLineEx const success = await vsc.saveActiveDocument(content)\n * @see http://vsc-base.org/#saveActiveDocument\n * @returns Promise<boolean>",
      "body": "export const saveActiveDocument = async (): Promise<boolean> => {\n   const doc = getActiveDocument()\n   if (doc) {\n      await doc.save()\n      return true\n   }\n   return new Promise(resolve => {\n      resolve(false)\n   })\n}\n"
   },
   {
      "meta": " * Save All files\n * @dependencyExternal vscode\n * @oneLineEx await vsc.saveAll()\n * @see http://vsc-base.org/#saveAll\n * @returns Promise<void>",
      "body": "export const saveAll = async (): Promise<void> => {\n   await vscode.workspace.saveAll(false)\n}\n"
   },
   {
      "meta": " * Save file\n * @param path\n * @param content\n * @dependencyExternal fs\n * @oneLineEx await vsc.saveFileContent(path, source)\n * @see http://vsc-base.org/#saveFileContent\n * @returns Promise<void>",
      "body": "export const saveFileContent = async (\n   path: string,\n   content: string\n): Promise<void> => {\n   await fs.writeFile(path, content)\n}\n"
   },
   {
      "meta": " * Recurvice function that goes through a template tree\n * @param path Full path to where the TemplateItem (file/folder) should be created\n * @param userInputs An object with user inputs {[key: string]: string}\n * @param templateItem An TemplateItem (folde/file)\n * @dependencyInternal makeDir, saveFileContent\n * @oneLineEx await scaffoldTemplate(path, template)\n * @see http://vsc-base.org/#scaffoldTemplate\n * @returns Promise<void>",
      "body": "export const scaffoldTemplate = async (\n   path: string,\n   templateItem: vscTemplateItem,\n   userInputs: vscUserInputs = {}\n): Promise<void> => {\n   switch (templateItem.type) {\n      case 'folder': {\n         let name = templateItem.name\n         if (typeof name === 'function') {\n            name = name.call(null, userInputs)\n         }\n         const folderPath = path + '/' + name\n         await makeDir(folderPath)\n         if (!templateItem.children) {\n            break\n         }\n         templateItem.children.forEach(async (childItem: any) => {\n            scaffoldTemplate(folderPath, childItem, userInputs)\n         })\n         break\n      }\n      case 'file': {\n         let name = templateItem.name\n         if (typeof name === 'function') {\n            name = name.call(null, userInputs)\n         }\n         const filePath = path + '/' + name\n         let content = templateItem.content\n         if (typeof content === 'function') {\n            content = content.call(null, userInputs)\n         }\n         await saveFileContent(filePath, content)\n      }\n   }\n}\n"
   },
   {
      "meta": " * Set current open file's content.\n * Return true if success, and false if there was no ActiveTextEditor or OpenDocument.\n * @param content\n * @dependencyInternal getActiveDocument, getActiveEditor\n * @dependencyExternal vscode\n * @oneLineEx const success = await vsc.setActiveDocumentContent(content)\n * @see http://vsc-base.org/#setActiveDocumentContent\n * @returns Promise<boolean>",
      "body": "export const setActiveDocumentContent = async (\n   content: string\n): Promise<boolean> => {\n   const document = getActiveDocument()\n   const editor = getActiveEditor()\n   if (editor && document) {\n      const fullRange = getFullDocumentRange(document)\n      const snippetString = new vscode.SnippetString(content)\n      await editor.insertSnippet(snippetString, fullRange)\n      return true\n   }\n   return false\n}\n"
   },
   {
      "meta": " * Return the path that are shared. (Return '' if no path are shared).\n * @param path1\n * @param path2\n * @see http://vsc-base.org/#sharedPath\n * @returns string",
      "body": "export const sharedPath = (path1: string, path2: string): string => {\n   const path1Parts = path1.split(/\\//)\n   const path2Parts = path2.split(/\\//)\n   const shared = []\n   for (let i = 0; i < path1Parts.length; i++) {\n      if (!path2Parts[i] || path1Parts[i] !== path2Parts[i]) {\n         break\n      }\n      shared.push(path1Parts[i])\n   }\n   const finalShared = shared.join('/')\n   return finalShared\n}\n"
   },
   {
      "meta": " * Show error message to user\n * @param message\n * @dependencyExternal vscode\n * @oneLineEx await vsc.showErrorMessage(message)\n * @see http://vsc-base.org/#showErrorMessage\n * @returns Promise<void>",
      "body": "export const showErrorMessage = async (message: string): Promise<void> => {\n   await vscode.window.showErrorMessage(message)\n}\n"
   },
   {
      "meta": " * Show message to user\n * @param message\n * @dependencyExternal vscode\n * @oneLineEx await vsc.showMessage(message)\n * @see http://vsc-base.org/#showMessage\n * @returns Promise<void>",
      "body": "export const showMessage = async (message: string): Promise<void> => {\n   await vscode.window.showInformationMessage(message)\n}\n"
   },
   {
      "meta": " * await wrap for setTimeout. Mostly used for debug asyc.\n * @param ms\n * @see http://vsc-base.org/#sleep\n * @async\n * @returns any",
      "body": "export const sleep = async (ms: number): Promise<void> => {\n   return new Promise(resolve => setTimeout(resolve, ms))\n}\n"
   },
   {
      "meta": " * Split path into dir and file\n * @param path\n * @dependencyInternal pathAsUnix\n * @see http://vsc-base.org/#splitPath\n * @returns [dir, name]",
      "body": "export const splitPath = (path: string): [string, string] => {\n   path = pathAsUnix(path)\n   const splits = path.split('/')\n   const name = splits.pop() || ''\n   const dir = splits.join('/')\n   return [dir, name]\n}\n"
   },
   {
      "meta": " * Remove parent-path from a path\n * @param path\n * @param parentPath\n * @param trimDashes default true\n * @dependencyInternal trimDashes\n * @see http://vsc-base.org/#subtractPath\n * @returns string",
      "body": "export const subtractPath = (\n   path: string,\n   parentPath: string,\n   _trimDashes = true\n): string => {\n   const regexp = new RegExp(`^${parentPath}`)\n   let newPath = path.replace(regexp, '')\n   if (trimDashes) {\n      newPath = trimDashes(newPath)\n   }\n   return newPath\n}\n"
   },
   {
      "meta": " * Format a string to camal-case. Commonly used to define js/ts variable names.\n * (Some-Name => someName, some_name => someName, some.name => someName )\n * All non word seperators will be removed and the word charector after will be transforms to upper case\n * @param str\n * @see http://vsc-base.org/#toCamelcase\n * @returns string",
      "body": "export const toCamelcase = (str: string): string =>\n   str[0].toLowerCase() +\n   str.substr(1).replace(/[^a-zA-Z]+(.)/g, (_match, chr) => chr.toUpperCase())\n"
   },
   {
      "meta": " * Remove '/' from start and end of path\n * @param path\n * @see http://vsc-base.org/#trimDashes\n * @returns string",
      "body": "export const trimDashes = (path: string): string => {\n   return path.replace(/(^\\/|\\/$)/g, '')\n}\n"
   },
   {
      "meta": " * Remove '/' from start of path\n * @param path\n * @see http://vsc-base.org/#trimLeadingDash\n * @returns string",
      "body": "export const trimLeadingDash = (path: string): string => {\n   return path.replace(/^\\//, '')\n}\n"
   },
   {
      "meta": " * Test if a loaded module has methods (Loaded with vsc.loadTsModule)\n * return undefined if a method didnt exist.\n * @oneLineEx const varifyModuleMethods = vsc.hasModuleFunction(_module, methodName)\n * @ex \nconst varifiedModule = vsc.hasModuleFunction(_module, \\['run', 'getId'\\])\nconst result = varifiedModule.run()\n * @see http://vsc-base.org/#varifyModuleMethods\n * @returns { [key: string]: any } | undefined",
      "body": "export const varifyModuleMethods = (\n   _module: { [key: string]: unknown },\n   methods: string[]\n): { [key: string]: any } | undefined => {\n   const map: { [key: string]: any } = {}\n   for (const key of methods) {\n      if (_module.hasOwnProperty(key) && _module[key] instanceof Function) {\n         map[key] = _module[key]\n      } else {\n         return undefined\n      }\n   }\n   return map\n}\n"
   }
]